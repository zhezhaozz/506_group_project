sig = 1 * diag(p)
x = mvrnorm(n, mu = c(0,0,0,0,0), Sigma = sig)
beta = c( 6, 3.5, 7.6, 1.2, 2)
f =  x %*% beta * x %*% beta
hessian = 2 *  ( beta %*% t(beta) )
e = rnorm(n)
y = f + e
beta_hat = list()
for(i in 1:n) {
xx = x[i,] %*% t(x[i,])
ele = (y[i] - mean(y) ) * xx
beta_hat[[i]] = eigen(ele)$vector[,1]
}
sum( ( beta - beta_hat )^2 ) / n
beta_hat
beta
s = 0
for(j in 1:length(beta_hat)) {
s = s + sum( ( beta - beta_hat[[j]] )^2 )
}
s / n
# part d
set.seed(2019)
n = 1e6
p = 5
sig = 1 * diag(p)
x = mvrnorm(n, mu = c(0,0,0,0,0), Sigma = sig)
beta = c( 6, 3.5, 7.6, 1.2, 2)
f =  x %*% beta * x %*% beta
hessian = 2 *  ( beta %*% t(beta) )
# part d
set.seed(2019)
n = 1e6
p = 5
sig = 1 * diag(p)
x = mvrnorm(n, mu = c(0,0,0,0,0), Sigma = sig)
beta = c( 6, 3.5, 7.6, 1.2, 2)
f =  x %*% beta * x %*% beta
hessian = 2 *  ( beta %*% t(beta) )
e = rnorm(n)
y = f + e
beta_hat = list()
for(i in 1:n) {
xx = x[i,] %*% t(x[i,])
ele = (y[i] - mean(y) ) * xx
beta_hat[[i]] = eigen(ele)$vector[,1]
}
s = 0
for(j in 1:length(beta_hat)) {
s = s + sum( ( beta - beta_hat[[j]] )^2 )
}
s / n
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, cache = TRUE)
# question 4 -------------------------------------------------------------------
# part b
set.seed(2019)
n = 1e6
p = 5
sig = 1 * diag(p)
x = mvrnorm(n, mu = c(0,0,0,0,0), Sigma = sig)
library(MASS)
library(quantreg)
# install.packages('mvtnorm')
library(mvtnorm)
set.seed(2019)
# question 4 -------------------------------------------------------------------
# part b
set.seed(2019)
n = 1e6
p = 5
sig = 1 * diag(p)
x = mvrnorm(n, mu = c(0,0,0,0,0), Sigma = sig)
beta = c( 6, -1, 3.5, 8, 7.6)
f =  x %*% beta * x %*% beta
hessian = 2 *  ( beta %*% t(beta) )
y = c()
xx_list = list()
for(i in 1:n) {
e = rnorm(1)
y[i] = f[i] + e
xx = x[i,] %*% t(x[i,])
xx_list[[i]] = xx
}
equa_y =  y - mean(y)
equa_mat = list()
for(j in 1:length(equa_y)){
ele = equa_y[j] * xx_list[[j]]
equa_mat[[j]] = ele
}
E_y = Reduce("+", equa_mat) / length(equa_mat)
norm(E_y - hessian, type = "F")
# part c
# if x is not normal
set.seed(2019)
n = 1e5
p = 3
sig = 1 * diag(p)
x = rmvt(n, sigma = sig, df = 30)
beta = c( 6, 3.5, 7.6)
f =  x %*% beta * x %*% beta
hessian = 2 *  ( beta %*% t(beta) )
e = rnorm(n)
y = f + e
equa_list = list()
for(i in 1:n) {
xx = x[i,] %*% t(x[i,])
ele = (y[i] - mean(y) ) * xx
equa_list[[i]] = ele
}
E_y_ng = Reduce("+", equa_list) / length(equa_list)
norm(E_y_ng - hessian, "F")
# part d
beta_hat = eigen(E_y)$vector[,1]
beta_hat
beta_hat / mean(beta_hat)
beta_hat / mean(2*beta_hat)
beta_hat/beta
eigen(E_y
)
beta = c( 6, -1, 3.5, 8, 7.6)
beta_hat/beta
beta_hat/mean(beta_hat)
beta_hat/2*mean(beta_hat)
beta_hat/mean(2*beta_hat)
2*beta_hat
beta_hat/mean(4*beta_hat)
beta_hat/mean(beta_hat/4)
beta_hat/4
# part d
beta_hat = eigen(E_y)$vector[,1]
beta_hat/beta
# part d
beta_hat = eigen(E_y)$vector[,1]
beta_hat/beta
# part d
beta_hat = eigen(E_y)$vector[,1]
constant = beta_hat/beta
constant
constant
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
# question 4 -------------------------------------------------------------------
# part b
set.seed(2019)
n = 1e6
p = 5
sig = 1 * diag(p)
x = mvrnorm(n, mu = c(0,0,0,0,0), Sigma = sig)
beta = c( 6, -1, 3.5, 8, 7.6)
f =  x %*% beta * x %*% beta
hessian = 2 *  ( beta %*% t(beta) )
y = c()
xx_list = list()
for(i in 1:n) {
e = rnorm(1)
y[i] = f[i] + e
xx = x[i,] %*% t(x[i,])
xx_list[[i]] = xx
}
equa_y =  y - mean(y)
equa_mat = list()
for(j in 1:length(equa_y)){
ele = equa_y[j] * xx_list[[j]]
equa_mat[[j]] = ele
}
E_y = Reduce("+", equa_mat) / length(equa_mat)
norm(E_y - hessian, type = "F")
# part d
beta_hat = eigen(E_y)$vector[,1]
constant = beta_hat/beta
constant
beta_hat
beta_hat/beta
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
# part d
beta_hat = eigen(E_y)$vector[,1]
# question 4 -------------------------------------------------------------------
# part b
set.seed(2019)
n = 1e6
p = 5
sig = 1 * diag(p)
x = mvrnorm(n, mu = c(0,0,0,0,0), Sigma = sig)
library(MASS)
library(quantreg)
# install.packages('mvtnorm')
library(mvtnorm)
set.seed(2019)
# question 4 -------------------------------------------------------------------
# part b
set.seed(2019)
n = 1e6
p = 5
sig = 1 * diag(p)
x = mvrnorm(n, mu = c(0,0,0,0,0), Sigma = sig)
beta = c( 6, -1, 3.5, 8, 7.6)
f =  x %*% beta * x %*% beta
hessian = 2 *  ( beta %*% t(beta) )
y = c()
xx_list = list()
for(i in 1:n) {
e = rnorm(1)
y[i] = f[i] + e
xx = x[i,] %*% t(x[i,])
xx_list[[i]] = xx
}
equa_y =  y - mean(y)
equa_mat = list()
for(j in 1:length(equa_y)){
ele = equa_y[j] * xx_list[[j]]
equa_mat[[j]] = ele
}
E_y = Reduce("+", equa_mat) / length(equa_mat)
norm(E_y - hessian, type = "F")
# part d
beta_hat = eigen(E_y)$vector[,1]
constant = beta_hat/beta
constant
constant
# part d
beta_hat = eigen(E_y)$vector[,1]
constant = beta_hat/beta
constant
# part d
beta_hat = eigen(E_y)$vector[,1]
constant = beta_hat/beta
constant
install.packages("knitr")
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(magrittr)
library(splines)
library(car)
library(effects)
library(dplyr)
# read the data
dt = fread("cleaned_data.csv")
analysis_dt = fread("cleaned_data.csv")
knitr::opts_chunk$set(echo = TRUE)
mcreps = 1e4
n = 1e3
x = runif(n, 2, 4)
beta = 10
mu = exp( 2 + x*beta )
beta0_ols = c()
beta1_ols = c()
for(i in 1:mcreps) {
y = rpois(n, mu)
logy = log(y)
fit = lm(logy~x)
beta0_ols = append(beta0_ols, fit$coefficients[1])
beta1_ols = append(beta1_ols, fit$coefficients[2])
}
mcreps = 1e4
n = 1e3
x = runif(n, 1, 2)
beta = 3
mu = exp( 2 + x*beta )
beta0_ols = c()
beta1_ols = c()
for(i in 1:mcreps) {
y = rpois(n, mu)
logy = log(y)
fit = lm(logy~x)
beta0_ols = append(beta0_ols, fit$coefficients[1])
beta1_ols = append(beta1_ols, fit$coefficients[2])
}
mean( sqrt( (beta0_ols-2)^2 + (beta1_ols-beta)^2 ) )
mcreps = 1e4
n = 1e3
x = runif(n, 1, 2)
beta = 6
mu = exp( 2 + x*beta )
beta0_ols = c()
beta1_ols = c()
for(i in 1:mcreps) {
y = rpois(n, mu)
logy = log(y)
fit = lm(logy~x)
beta0_ols = append(beta0_ols, fit$coefficients[1])
beta1_ols = append(beta1_ols, fit$coefficients[2])
}
mean( sqrt( (beta0_ols-2)^2 + (beta1_ols-beta)^2 ) )
mcreps = 1e4
n = 1e3
x = runif(n, 1, 2)
beta = 1
mu = exp( 2 + x*beta )
beta0_ols = c()
beta1_ols = c()
for(i in 1:mcreps) {
y = rpois(n, mu)
logy = log(y)
fit = lm(logy~x)
beta0_ols = append(beta0_ols, fit$coefficients[1])
beta1_ols = append(beta1_ols, fit$coefficients[2])
}
mean( sqrt( (beta0_ols-2)^2 + (beta1_ols-beta)^2 ) )
mcreps = 1e4
n = 1e3
x = runif(n, 1, 2)
beta = 6
mu = exp( 2 + x*beta )
beta0_ols = c()
beta1_ols = c()
for(i in 1:mcreps) {
y = rpois(n, mu)
logy = log(y)
fit = lm(logy~x)
beta0_ols = append(beta0_ols, fit$coefficients[1])
beta1_ols = append(beta1_ols, fit$coefficients[2])
}
mean( sqrt( (beta0_ols-2)^2 + (beta1_ols-beta)^2 ) )
mcreps = 1e4
n = 1e3
x = runif(n, 1, 1.5)
beta = 1
mu = exp( 2 + x*beta )
beta0_ols = c()
beta1_ols = c()
for(i in 1:mcreps) {
y = rpois(n, mu)
logy = log(y)
fit = lm(logy~x)
beta0_ols = append(beta0_ols, fit$coefficients[1])
beta1_ols = append(beta1_ols, fit$coefficients[2])
}
mean( sqrt( (beta0_ols-2)^2 + (beta1_ols-beta)^2 ) )
mcreps = 1e4
n = 1e3
x = runif(n, 1, 1.5)
beta = 10
mu = exp( 2 + x*beta )
beta0_ols = c()
beta1_ols = c()
for(i in 1:mcreps) {
y = rpois(n, mu)
logy = log(y)
fit = lm(logy~x)
beta0_ols = append(beta0_ols, fit$coefficients[1])
beta1_ols = append(beta1_ols, fit$coefficients[2])
}
mean( sqrt( (beta0_ols-2)^2 + (beta1_ols-beta)^2 ) )
1e4*8
5e3*48
80000+240000
1e4*5e3*4
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
# sample size 200
j = 2
i = 200
tau_hat = seq(0.2, 0.8, length.out = 1000)
tau = 0.5
sig = diag(j) + tau * rep(1, j) %*% t( rep( 1,j ) )
y = c()
for (z in 1:i) {
y = rbind( y, mvrnorm(j, mu = c(0,0), Sigma = sig) )
}
l = c()
for (x in tau_hat){
l = append(l,
( -(400)/2 )*log(2*pi) -
( -(400)/2 )*log(1+x) - (1/2) * ( ( (1+x)/(1+2*x) ) * sum(y[,1]^2 + y[,2]^2) ) +
( ( (1+x)/(1+2*x) )*sum(y[,1]*y[,2]) )
)
}
plot(tau_hat, l)
j = 2
i = 50
tau_hat = seq(0.2, 0.8, length.out = 1000)
tau = 0.5
sig = diag(j) + tau * rep(1, j) %*% t( rep( 1,j ) )
y = c()
for (z in 1:i) {
y = rbind( y, mvrnorm(j, mu = c(0,0), Sigma = sig) )
}
l = c()
for (x in tau_hat){
l = append(l,
( -(100)/2 )*log(2*pi) -
( -(100)/2 )*log(1+x) - (1/2) * ( ( (1+x)/(1+2*x) ) * sum(y[,1]^2 + y[,2]^2) ) +
( ( (1+x)/(1+2*x) )*sum(y[,1]*y[,2]) )
)
}
plot(tau_hat, l)
j = 2
i = 50
tau_hat = seq(0.2, 10, length.out = 1000)
tau = 0.5
sig = diag(j) + tau * rep(1, j) %*% t( rep( 1,j ) )
y = c()
for (z in 1:i) {
y = rbind( y, mvrnorm(j, mu = c(0,0), Sigma = sig) )
}
l = c()
for (x in tau_hat){
l = append(l,
( -(100)/2 )*log(2*pi) -
( -(100)/2 )*log(1+x) - (1/2) * ( ( (1+x)/(1+2*x) ) * sum(y[,1]^2 + y[,2]^2) ) +
( ( (1+x)/(1+2*x) )*sum(y[,1]*y[,2]) )
)
}
plot(tau_hat, l)
j = 2
i = 50
tau_hat = seq(0.2, 100, length.out = 1000)
tau = 0.5
sig = diag(j) + tau * rep(1, j) %*% t( rep( 1,j ) )
y = c()
for (z in 1:i) {
y = rbind( y, mvrnorm(j, mu = c(0,0), Sigma = sig) )
}
l = c()
for (x in tau_hat){
l = append(l,
( -(100)/2 )*log(2*pi) -
( -(100)/2 )*log(1+x) - (1/2) * ( ( (1+x)/(1+2*x) ) * sum(y[,1]^2 + y[,2]^2) ) +
( ( (1+x)/(1+2*x) )*sum(y[,1]*y[,2]) )
)
}
plot(tau_hat, l)
j = 2
i = 50
tau_hat = seq(0.2, 100, length.out = 1000)
tau = 0.5
sig = diag(j) + tau * rep(1, j) %*% t( rep( 1,j ) )
y = c()
for (z in 1:i) {
y = rbind( y, mvrnorm(j, mu = c(0,0), Sigma = sig) )
}
l = c()
for (x in tau_hat){
l = append(l,
exp( ( -(100)/2 )*log(2*pi) -
( -(100)/2 )*log(1+x) - (1/2) * ( ( (1+x)/(1+2*x) ) * sum(y[,1]^2 + y[,2]^2) ) +
( ( (1+x)/(1+2*x) )*sum(y[,1]*y[,2]) ) )
)
}
plot(tau_hat, l)
j = 2
i = 50
tau_hat = seq(0.2, 1, length.out = 1000)
tau = 0.5
sig = diag(j) + tau * rep(1, j) %*% t( rep( 1,j ) )
y = c()
for (z in 1:i) {
y = rbind( y, mvrnorm(j, mu = c(0,0), Sigma = sig) )
}
l = c()
for (x in tau_hat){
l = append(l,
exp( ( -(100)/2 )*log(2*pi) -
( -(100)/2 )*log(1+x) - (1/2) * ( ( (1+x)/(1+2*x) ) * sum(y[,1]^2 + y[,2]^2) ) +
( ( (1+x)/(1+2*x) )*sum(y[,1]*y[,2]) ) )
)
}
plot(tau_hat, l)
j = 2
i = 50
tau_hat = seq(0.2, 0.8, length.out = 1000)
tau = 0.5
sig = diag(j) + tau * rep(1, j) %*% t( rep( 1,j ) )
y = c()
for (z in 1:i) {
y = rbind( y, mvrnorm(j, mu = c(0,0), Sigma = sig) )
}
l = c()
for (x in tau_hat){
l = append(l,
exp( ( -(100)/2 )*log(2*pi) -
( -(100)/2 )*log(1+x) - (1/2) * ( ( (1+x)/(1+2*x) ) * sum(y[,1]^2 + y[,2]^2) ) +
( ( (1+x)/(1+2*x) )*sum(y[,1]*y[,2]) ) )
)
}
plot(tau_hat, l)
j = 2
i = 50
tau_hat = seq(0.2, 0.6, length.out = 1000)
tau = 0.5
sig = diag(j) + tau * rep(1, j) %*% t( rep( 1,j ) )
y = c()
for (z in 1:i) {
y = rbind( y, mvrnorm(j, mu = c(0,0), Sigma = sig) )
}
l = c()
for (x in tau_hat){
l = append(l,
exp( ( -(100)/2 )*log(2*pi) -
( -(100)/2 )*log(1+x) - (1/2) * ( ( (1+x)/(1+2*x) ) * sum(y[,1]^2 + y[,2]^2) ) +
( ( (1+x)/(1+2*x) )*sum(y[,1]*y[,2]) ) )
)
}
plot(tau_hat, l)
j = 2
i = 50
tau_hat = seq(0.2, 0.3, length.out = 1000)
tau = 0.5
sig = diag(j) + tau * rep(1, j) %*% t( rep( 1,j ) )
y = c()
for (z in 1:i) {
y = rbind( y, mvrnorm(j, mu = c(0,0), Sigma = sig) )
}
l = c()
for (x in tau_hat){
l = append(l,
exp( ( -(100)/2 )*log(2*pi) -
( -(100)/2 )*log(1+x) - (1/2) * ( ( (1+x)/(1+2*x) ) * sum(y[,1]^2 + y[,2]^2) ) +
( ( (1+x)/(1+2*x) )*sum(y[,1]*y[,2]) ) )
)
}
plot(tau_hat, l)
setwd("~/Desktop/Math_Courses/Umich/506/506_group_project/zzhaozhe")
